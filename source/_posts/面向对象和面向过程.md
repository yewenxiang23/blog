---
title: 面向对象和面向过程
date: 2018-09-29 12:02:57
categories: js
tags:
---

### 面向过程（Procedure-oriented）

比如写3个对输入框输入数据校验功能的方法，用了3个函数这是一种面向过程的实现方式。

弊端：
  - 无端的在页面中添加了很多全局变量。
  - 不利于别人重复利用
  - 一旦别人使用你以前提供的方法，你就不能轻易的去修改这些方法，不利于团队代码维护

### 面向对象

面向对象：就是将你的需求抽象成一个对象，然后针对这个对象分析其特征（属性）和动作（方法），这个对象我们称之为类

封装：就是把你需要的功能放在一个对象里

#### 通过 this 添加的属性和方法同在prototype中添加的属性和方法有什么区别？

通过this 添加的属性和方法是在当前对象添加的，prototype中添加的属性和方法不是对象自身的，而是对象继承而来的，也就是每个对象通过prototype访问到的，所以我们我们每次通过类创建一个新对象时，这些属性和方法不会再次创建

### 类的私有变量和私有方法

由于JS的函数级作用域，声明在函数内部的变量以及方法在外界是访问不到的，通过这个特性来创建类的私有变量和私有方法。

### 类的公有变量和公有方法

在函数内部通过this创建的属性和方法，在类创建对象时，每个对象都拥有一份并且可以在外部访问到。 **因此通过对象创建的属性可看做是对象的共有属性和共有方法**

### 类的特权方法

通过this创建的方法，不但能访问对象的公有属性和公有方法，而且还能访问到 **父类或者对象自身** 的私有属性和私有方法，由于这些方法权利比较大，所以称之为特权方法

### 类的构造器

在对象创建时通过使用 特权方法 我们可以初始化实例对象的一些属性，因此这些在创建对象时调用的特权方法还可以看作是类的构造器

```js
var Book = function(id, name, price){
  var num = 1;         //私有属性
  function checkId(){} //私有方法

  this.id = id;               //公有属性
  this.copy = function(){}    //公有方法

  this.getName = function(){   //特权方法
      //在函数内能访问创建出来对象的公有属性和公有方法，还能访问到父类或者对象自身的私有属性和私有方法
  }
  this.getName(name)   //构造器
}
```

### 类的静态共有属性和类的共有静态方法

静态共有属性和类的共有静态方法： 通过类在外面通过点语法定义的属性以及方法

通过new关键字创建新的对象时，由于类外面通过点语法添加的属性和方法没有执行到，所以新创建的对象中无法获取他们，但是可以通过类来使用。

### 类的共有属性和共有方法

类通过prototype 创建的属性或者方法，在类实例的对象中是可以通过this访问到的，所以把prototype对象中的属性和方法称为共有属性和共有方法。

```js
Book.isChinese = true;  //类静态共有属性（子类对象不能访问）
Book.resetTime = function(){  //类静态共有方法（子类对象不能访问）
  console.log('new Time')
}

Book.proptype = {
  isJSBook:false,         //共有属性
  display:function(){}    //共有方法
}
```

>通过new 关键字创建的对象实质是对新对象this的不断赋值，并将prototype指向类的prototype 所指的对象。
>

### 创建对象的安全模式

```js
var Book = funtion(title,name,type){
  if(this instanceof Book){  //判断执行过程中this是否指向当前对象（如果是说明是当前对象，如果没有使用new，this指向的是window对象）
    this.title = title;
    this.time = time;
    this.type = type;
  }else {
    return new Book(title,name,type)
  }
}
```
